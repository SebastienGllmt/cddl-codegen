"use strict";(self.webpackChunkcddl_codegen_documentation=self.webpackChunkcddl_codegen_documentation||[]).push([[163],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=d(n),m=i,h=p["".concat(l,".").concat(m)]||p[m]||c[m]||r;return n?a.createElement(h,o(o({ref:t},u),{},{components:n})):a.createElement(h,o({ref:t},u))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:i,o[1]=s;for(var d=2;d<r;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1217:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var a=n(7462),i=(n(7294),n(3905));const r={sidebar_position:7},o="Comment DSL",s={unversionedId:"comment_dsl",id:"comment_dsl",title:"Comment DSL",description:"We have a comment DSL to help annotate the output code beyond what is possible just with CDDL.",source:"@site/docs/comment_dsl.mdx",sourceDirName:".",slug:"/comment_dsl",permalink:"/cddl-codegen/comment_dsl",draft:!1,tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Wasm Differences",permalink:"/cddl-codegen/wasm_differences"},next:{title:"Examples",permalink:"/cddl-codegen/examples"}},l={},d=[{value:"@name",id:"name",level:2},{value:"@newtype",id:"newtype",level:2},{value:"@no_alias",id:"no_alias",level:2},{value:"@used_as_key",id:"used_as_key",level:2},{value:"@custom_json",id:"custom_json",level:2},{value:"@custom_serialize / @custom_deserialize",id:"custom_serialize--custom_deserialize",level:2},{value:"@doc",id:"doc",level:2},{value:"<em>CDDL_CODEGEN_EXTERN_TYPE</em>",id:"cddl_codegen_extern_type",level:2},{value:"<em>CDDL_CODEGEN_RAW_BYTES_TYPE</em>",id:"cddl_codegen_raw_bytes_type",level:2}],u={toc:d},p="wrapper";function c(e){let{components:t,...n}=e;return(0,i.kt)(p,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"comment-dsl"},"Comment DSL"),(0,i.kt)("p",null,"We have a comment DSL to help annotate the output code beyond what is possible just with CDDL."),(0,i.kt)("h2",{id:"name"},"@name"),(0,i.kt)("p",null,"For example in an array-encoded group you can give explicit names just by the keys e.g.:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cddl"},"foo = [\n    bar: uint,\n    baz: text\n]\n")),(0,i.kt)("p",null,"but with map-encoded structs the keys are stored and for things like integer keys this isn't very helpful e.g.:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cddl"},"tx = {\n  ? 0: [* input],\n  ? 1: [* outputs],\n}\n")),(0,i.kt)("p",null,"we would end up with two fields: ",(0,i.kt)("inlineCode",{parentName:"p"},"key_0")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"key_1"),". We can instead end up with fields named ",(0,i.kt)("inlineCode",{parentName:"p"},"inputs")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"outputs")," by doing:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cddl"},"tx = {\n  ? 0: [* input],   ; @name inputs\n  ? 1: [* outputs], ; @name outputs\n}\n")),(0,i.kt)("p",null,"Note: the parsing can be finicky. For struct fields you must put the comment AFTER the comma, and the comma must exist even for the last field in a struct."),(0,i.kt)("p",null,"It is also possible to use ",(0,i.kt)("inlineCode",{parentName:"p"},"@name")," with type choices:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cddl"},"foo = 0 ; @name mainnet\n    / 1 ; @name testnet\n")),(0,i.kt)("p",null,"and also for group choices:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cddl"},"script = [\n  ; @name native\n  tag: 0, script: native_script //\n  ; @name plutus_v1\n  tag: 1, script: plutus_v1_script //\n  ; @name plutus_v2\n  tag: 2, script: plutus_v2_script\n]\n")),(0,i.kt)("h2",{id:"newtype"},"@newtype"),(0,i.kt)("p",null,"With code like ",(0,i.kt)("inlineCode",{parentName:"p"},"foo = uint")," this creates an alias e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"pub type Foo = u64;")," in rust. When we use ",(0,i.kt)("inlineCode",{parentName:"p"},"foo = uint ; @newtype")," it instead creates a ",(0,i.kt)("inlineCode",{parentName:"p"},"pub struct Foo(u64);"),"."),(0,i.kt)("h2",{id:"no_alias"},"@no_alias"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cddl"},"foo = uint\nbar = [\n  field: foo\n]\n")),(0,i.kt)("p",null,"This would normally result in:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"pub type Foo = u64;\npub struct Bar {\n    field: Foo,\n}\n")),(0,i.kt)("p",null,"but if we use ",(0,i.kt)("inlineCode",{parentName:"p"},"@no_alias")," it skips generating an alias and uses it directly e.g.:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cddl"},"foo = uint ; @no_alias\nbar = [\n  field: foo\n]\n")),(0,i.kt)("p",null,"to"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct Bar {\n    field: u64,\n}\n")),(0,i.kt)("h2",{id:"used_as_key"},"@used_as_key"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cddl"},"foo = [\n  x: uint,\n  y: uint,\n] ; @used_as_Key\n")),(0,i.kt)("p",null,"cddl-codegen automatically derives ",(0,i.kt)("inlineCode",{parentName:"p"},"Ord"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"PartialOrd")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Hash")," for any types used within as a key in another type.\nPutting this comment on a type forces that type to derive those traits even if it weren't used in a key in the cddl spec.\nThis is useful for when you are writing utility code that would put them in a map and want the generated code to have it already,\nwhich is particularly useful for re-generating as it lets your ",(0,i.kt)("inlineCode",{parentName:"p"},"mod.rs")," files remain untouched."),(0,i.kt)("h2",{id:"custom_json"},"@custom_json"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cddl"},"foo = uint ; @newtype @custom_json\n")),(0,i.kt)("p",null,"Avoids generating and/or deriving json-related traits under the assumption that the user will supply their own implementation to be used in the generated library."),(0,i.kt)("h2",{id:"custom_serialize--custom_deserialize"},"@custom_serialize / @custom_deserialize"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cddl"},"custom_bytes = bytes ; @custom_serialize custom_serialize_bytes @custom_deserialize custom_deserialize_bytes\n\nstruct_with_custom_serialization = [\n  custom_bytes,\n  field: bytes, ; @custom_serialize custom_serialize_bytes @custom_deserialize custom_deserialize_bytes\n  overridden: custom_bytes, ; @custom_serialize write_hex_string @custom_deserialize read_hex_string\n  tagged1: #6.9(custom_bytes),\n  tagged2: #6.9(uint), ; @custom_serialize write_tagged_uint_str @custom_deserialize read_tagged_uint_str \n]\n")),(0,i.kt)("p",null,"This allows the overriding of serialization and/or deserialization for when a specific format must be maintained. This works even with primitives where ",(0,i.kt)("em",{parentName:"p"},"CDDL_CODEGEN_EXTERN_TYPE")," would require making a wrapper type to use."),(0,i.kt)("p",null,"The string after ",(0,i.kt)("inlineCode",{parentName:"p"},"@custom_serialize"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"@custom_deserialize")," will be directly called as a function in place of regular serialization/deserialization code. As such it must either be specified using fully qualified paths e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"@custom_serialize crate::utils::custom_serialize_function"),", or post-generation it will need to be imported into the serialization code by hand e.g. adding ",(0,i.kt)("inlineCode",{parentName:"p"},"import crate::utils::custom_serialize_function;"),"."),(0,i.kt)("p",null,"With ",(0,i.kt)("inlineCode",{parentName:"p"},"--preserve-encodings=true")," the encoding variables must be passed in in the order they are used in cddl-codegen with regular serialization. They are passed in as ",(0,i.kt)("inlineCode",{parentName:"p"},"Option<cbor_event::Sz>")," for integers/tags, ",(0,i.kt)("inlineCode",{parentName:"p"},"LenEncoding")," for lengths and ",(0,i.kt)("inlineCode",{parentName:"p"},"StringEncoding")," for text/bytes. These are the same types as are stored in the ",(0,i.kt)("inlineCode",{parentName:"p"},"*Encoding")," structs generated. The same must be returned for deserialization. When there are no encoding variables the deserialized value should be directly returned, and if not a tuple with the value and its encoding variables should be returned."),(0,i.kt)("p",null,"There are two ways to use this comment DSL:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Type level: e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"custom_bytes"),". This will replace the (de)serialization everywhere you use this type."),(0,i.kt)("li",{parentName:"ul"},"Field level: e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"struct_with_custom_serialization.field"),". This will entirely replace the (de)serialization logic for the entire field, including other encoding operations like tags, ",(0,i.kt)("inlineCode",{parentName:"li"},".cbor"),", etc.")),(0,i.kt)("p",null,"Example function signatures for ",(0,i.kt)("inlineCode",{parentName:"p"},"--preserve-encodings=false")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"custom_serialize_bytes")," / ",(0,i.kt)("inlineCode",{parentName:"p"},"custom_deserialize_bytes")," above:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn custom_serialize_bytes<'se, W: std::io::Write>(\n    serializer: &'se mut cbor_event::se::Serializer<W>,\n    bytes: &[u8],\n) -> cbor_event::Result<&'se mut cbor_event::se::Serializer<W>>\n\npub fn custom_deserialize_bytes<R: std::io::BufRead + std::io::Seek>(\n    raw: &mut cbor_event::de::Deserializer<R>,\n) -> Result<Vec<u8>, DeserializeError>\n")),(0,i.kt)("p",null,"Example function signatures for ",(0,i.kt)("inlineCode",{parentName:"p"},"--preserve-encodings=true")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"write_tagged_uint_str")," / ",(0,i.kt)("inlineCode",{parentName:"p"},"read_tagged_uint_str")," above:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn write_tagged_uint_str<'se, W: std::io::Write>(\n    serializer: &'se mut cbor_event::se::Serializer<W>,\n    uint: &u64,\n    tag_encoding: Option<cbor_event::Sz>,\n    text_encoding: Option<cbor_event::Sz>,\n) -> cbor_event::Result<&'se mut cbor_event::se::Serializer<W>>\n\npub fn read_tagged_uint_str<R: std::io::BufRead + std::io::Seek>(\n    raw: &mut cbor_event::de::Deserializer<R>,\n) -> Result<(u64, Option<cbor_event::Sz>, Option<cbor_event::Sz>), DeserializeError>\n")),(0,i.kt)("p",null,"Note that as this is at the field-level it must handle the tag as well as the ",(0,i.kt)("inlineCode",{parentName:"p"},"uint"),"."),(0,i.kt)("p",null,"For more examples see ",(0,i.kt)("inlineCode",{parentName:"p"},"tests/custom_serialization")," (used in the ",(0,i.kt)("inlineCode",{parentName:"p"},"core")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"core_no_wasm")," tests) and ",(0,i.kt)("inlineCode",{parentName:"p"},"tests/custom_serialization_preserve")," (used in the ",(0,i.kt)("inlineCode",{parentName:"p"},"preserve-encodings")," test)."),(0,i.kt)("h2",{id:"doc"},"@doc"),(0,i.kt)("p",null,"This can be placed at field-level, struct-level or variant-level to specify a comment to be placed as a rust doc-comment."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cddl"},"docs = [\n  foo: text, ; @doc this is a field-level comment\n  bar: uint, ; @doc bar is a u64\n] ; @doc struct documentation here\n\ndocs_groupchoice = [\n  ; @name first @doc comment-about-first\n  0, uint //\n  ; @doc comments about second @name second\n  text\n] ; @doc type-level comment\n")),(0,i.kt)("p",null,"Will generate:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"/// struct documentation here\n#[derive(Clone, Debug)]\npub struct Docs {\n    /// this is a field-level comment\n    pub foo: String,\n    /// bar is a u64\n    pub bar: u64,\n}\n\nimpl Docs {\n    /// * `foo` - this is a field-level comment\n    /// * `bar` - bar is a u64\n    pub fn new(foo: String, bar: u64) -> Self {\n        Self { foo, bar }\n    }\n}\n\n/// type-level comment\n#[derive(Clone, Debug)]\npub enum DocsGroupchoice {\n    /// comment-about-first\n    First(u64),\n    /// comments about second\n    Second(String),\n}\n")),(0,i.kt)("p",null,"Due to the comment dsl parsing this doc comment cannot contain the character ",(0,i.kt)("inlineCode",{parentName:"p"},"@"),"."),(0,i.kt)("h2",{id:"cddl_codegen_extern_type"},(0,i.kt)("em",{parentName:"h2"},"CDDL_CODEGEN_EXTERN_TYPE")),(0,i.kt)("p",null,"While not as a comment, this allows you to compose in hand-written structs into a cddl spec."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cddl"},"foo = _CDDL_CODEGEN_EXTERN_TYPE_\nbar = [\n    x: uint,\n    y: foo,\n]\n")),(0,i.kt)("p",null,"This will treat ",(0,i.kt)("inlineCode",{parentName:"p"},"Foo")," as a type that will exist and that has implemented the ",(0,i.kt)("inlineCode",{parentName:"p"},"Serialize")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Deserialize")," traits, so the (de)serialization logic in ",(0,i.kt)("inlineCode",{parentName:"p"},"Bar")," here will call ",(0,i.kt)("inlineCode",{parentName:"p"},"Foo::serialize()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Foo::deserialize()"),".\nThis can also be useful when you have a spec that is either very awkward to use (so you hand-write or hand-modify after generation) in some type so you don't generate those types and instead manually merge those hand-written/hand-modified structs back in to the code afterwards. This saves you from having to manually remove all code that is generated regarding ",(0,i.kt)("inlineCode",{parentName:"p"},"Foo")," first before merging in your own."),(0,i.kt)("p",null,"This can also be useful when you have a spec that is either very awkward to use (so you hand-write or hand-modify after generation) in some type so you don't generate those types and instead manually merge those hand-written/hand-modified structs back in to the code afterwards. This saves you from having to manually remove all code that is generated regarding ",(0,i.kt)("inlineCode",{parentName:"p"},"Foo")," first before merging in your own."),(0,i.kt)("p",null,"This also works with generics e.g. you can refer to ",(0,i.kt)("inlineCode",{parentName:"p"},"foo<T>"),". As with other generics this will create a ",(0,i.kt)("inlineCode",{parentName:"p"},"pub type FooT = Foo<T>;")," definition in rust to work with wasm-bindgen's restrictions (no generics) as on the wasm side there will be references to a ",(0,i.kt)("inlineCode",{parentName:"p"},"FooT")," in wasm. The wasm type definition is not emitted as that will be implementation-dependent. For an example see ",(0,i.kt)("inlineCode",{parentName:"p"},"extern_generic")," in the ",(0,i.kt)("inlineCode",{parentName:"p"},"core")," unit test."),(0,i.kt)("h2",{id:"cddl_codegen_raw_bytes_type"},(0,i.kt)("em",{parentName:"h2"},"CDDL_CODEGEN_RAW_BYTES_TYPE")),(0,i.kt)("p",null,"Allows encoding as ",(0,i.kt)("inlineCode",{parentName:"p"},"bytes")," but imposing hand-written constraints defined elsewhere."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cddl"},"foo = _CDDL_CODEGEN_RAW_BYTES_TYPE_\nbar = [\n    foo,\n]\n")),(0,i.kt)("p",null,"This will treat ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," as some external type called ",(0,i.kt)("inlineCode",{parentName:"p"},"Foo"),". This type must implement the exported (in ",(0,i.kt)("inlineCode",{parentName:"p"},"serialization.rs"),") trait ",(0,i.kt)("inlineCode",{parentName:"p"},"RawBytesEncoding"),".\nThis can be useful for example when working with cryptographic primitives e.g. a hash or pubkey, as it allows users to have those crypto structs be from a crypto library then they only need to implement the trait for them and they will be able to be directly used without needing any useless generated wrapper struct for the in between."))}c.isMDXComponent=!0}}]);