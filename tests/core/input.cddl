hash = bytes .size (0..8)

foo = [uint, text, bytes]

tagged_text = #6.42(text)

opt_text = tagged_text / null

foo2 = #6.23([uint, opt_text])

bar = {
	foo: #6.1337(foo),
	? derp: uint,
	1 : uint / null,
	? 5: text,
	five: 5,
}

plain = (d: #6.23(uint), e: tagged_text)
outer = [a: uint, b: plain, c: "some text"]

table = { * uint => text }

table_arr_members = {
	tab: { * text => text },
	arr: [*uint],
	arr2: [*foo],
}

type_choice = 0 / "hello world" / uint / text / bytes / #6.64([*uint])

group_choice = [ foo // 0, x: uint // plain ]

foo_bytes = bytes .cbor foo

; since we don't generate code for definitions like the above (should we if no one refers to it?)
cbor_in_cbor = [foo_bytes, uint_bytes: bytes .cbor uint]


u8 = uint .size 1
u16 = uint .le 65535
u32 = 0..4294967295
u64 = uint .size 8 ; 8 bytes
i8 = -128..127
i64 = int .size 8 ; 8 bytes